<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一维数组循环左移算法]]></title>
    <url>%2F2018%2F08%2F04%2F%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天复习数据结构遇到一个简单的算法，做一下记录。再简单的东西积累起来也能提高思考问题的感觉。这是关于一维数组循环左移的算法。两种方法，时间复杂度不一样，孰优孰劣很明显了。 问题描述&emsp;&emsp;设将n(n&gt;1)个整数存放到一维数组R中，设计算法，将R中的序列循环左移P(0&lt;p&lt;n)位,即将R中的数据由{X0,X1,…,Xn-1}变换成{Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1}。 算法1算法步骤： 第一步：将R中前P个元素逆置 第二步：将剩下的所有元素逆置 第三步：将R中所有元素再整体做一次逆置 算法2算法步骤： 第一步：重新设置一个临时变量，每次左移一位都将最低位赋值给它； 第二步：再将整个数组从第二位开始后面一位覆盖前面一位； 第三步：再将临时变量存的值赋给最高位 C++代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include "stdafx.h"#include &lt;iostream&gt;using namespace std;#define N 50//实现逆置void Reverse(int R[],int start,int end)&#123; int i, j, temp; for (int i = start, j = end; i &lt; j; i++, j--) &#123; temp = R[i]; R[i] = R[j]; R[j] = temp; &#125;&#125;//实现循环左移 算法1的复杂度： O(n)void ROL(int R[], int n, int p)&#123; if (p &lt; 0 || p &gt;= n) //循环移位P的限制 cout &lt;&lt; "error!" &lt;&lt; endl; else &#123; Reverse(R, 0, p - 1); //第一步：将R中前P个元素逆置 Reverse(R, p, n - 1); //第二步：将剩下的所有元素逆置 Reverse(R, 0, n - 1); //第三步：将R中所有元素再整体做一次逆置 &#125;&#125;int main()&#123; int P; //左移位数P int R[N], n; //声明一片可以存50个整数的数组R[N],n实际数组中存的个数 cout &lt;&lt; "**************算法1**************"&lt;&lt;endl; cout &lt;&lt; "输入左移位P和数组长度n:" &lt;&lt; endl; cin &gt;&gt; P &gt;&gt; n; for (int i = 0; i &lt; n; i++) //输入n个数组元素 cin &gt;&gt;R[i]; ROL(R, n, P); //调用循环左移的函数 for (int i = 0; i &lt; n; i++) cout &lt;&lt; R[i] &lt;&lt; " "; //输出数组 cout &lt;&lt; endl; //算法2：算法时间复杂度是O(n^2) cout &lt;&lt; "**************算法2**************"&lt;&lt;endl; int a[6] = &#123; 1,2,3,4,5,6 &#125;; //数组长度为6 int temp; for (int i = 0; i&lt;P; i++) //外循环,控制内循环次数以及最低位到最高位的移位 &#123; temp = a[0]; //最低位被更新之前存到变量temp中 for (int j = 0; j&lt;5; j++) //内循环从次低位开始,依次将数向低位移动一位 a[j] = a[j+1]; a[5] = temp; //更新最高位 &#125; for (int i = 0; i &lt; 6; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 结果输出： **算法1**输入左移位P和数组长度n:3 101 2 3 4 5 6 7 8 9 04 5 6 7 8 9 0 1 2 3**算法2**4 5 6 1 2 3 分析&emsp;&emsp;算法2容易想到，理解也很方便。算法1比较有技巧性，值得记忆学习。对于算法1可以举个实例验证一下。 1 2 3 4 5 6 7 8 9 0 3 2 1 0 9 8 7 6 5 4 4 5 6 7 8 9 0 1 2 3 &emsp;&emsp;上面的例子就是结果输出中的输入。第二行实现了算法1中的第一步和第二步，第三行实现了算法1中的第三步。最重要的是算法的时间复杂度分析：算法1只有一重for循环，故时间复杂度为O(n)；算法2有两重for循环，故时间复杂度为O(n^2)。类似的，也能得出一维数组循环右移的算法。]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辗转相除法(欧几里德算法)]]></title>
    <url>%2F2018%2F08%2F03%2F%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95(%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95)%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;复习专业课数据结构，总结学过的算法，不捡起来就忘光光了。今天总结第一个算法：求解任意自然数m和n的最大公约数。 辗转相除法(欧几里德算法)的求解过程&emsp;&emsp;对于任意自然数m和n，不妨设m&gt;n，求它们的最大公约数，步骤如下：&emsp;&emsp;第一步、如果n=0,计算结束,m就是最大公约数;&emsp;&emsp;第二步、否则,计算m除以n的余数,将n的值赋给m,将余数的值赋给n;&emsp;&emsp;第三步、回到第一步 原理(证明)假设： 求m和n的最大公约数。 a,b分别是m除以n的商和余数，即m=na+b。 gcd(m,n)表示m和n的最大公约数。求证：gcd(m,n)=gcd(n,b)证明：设c=gcd(m,n), d=gcd(n,b)∵c为m和n的公约数∴m能被c整除，n也能被c整除∴na也能被c整除 参照推论一∴m-na也能被c整除(即b能c整除) 参照推论二∴c为n和b的公约数∵d为n和b的最大公约数∴c≤d同理可证 d≤c∵d为n和b的公约数∴n能被d整除，b也能被d整除∴na也能被d整除 参照推论一∴na+b也能被d整除(即m能d整除) 参照推论二∴d为m和n的公约数∵c为m和n的最大公约数∴d≤c综上所述：c=d，即gcd(m,n)=gcd(n,b) 推论一：若a能被b整除(a=tb)，则如果k为正整数，则ka也能被b整除(ka=ktb)。推论二：若a能被c整除，b也能被c整除，则(a±b)也能被c整除。 C++实现算法123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int a,b,num1,num2,temp; cin&gt;&gt;num1&gt;&gt;num2; if(num1&lt;num2) //先将两个数排出大小 &#123; temp=num1; num1=num2; num2=temp; &#125; a=num1; b=num2; while(b!=0) //碾转相除法求最大公约数 &#123; temp=a%b; a=b; b=temp; &#125; cout&lt;&lt;a&lt;&lt;endl; //最大公约数 cout&lt;&lt;(num1*num2/a)&lt;&lt;endl; //最小公倍数=两数之积除以最大公约数 return 0;&#125; &emsp;&emsp;辗转相除法的时间复杂度为O(logN)。]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关头文件的有趣发现]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%9C%89%E5%85%B3stdio.h%E7%9A%84%E6%9C%89%E8%B6%A3%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天复习C语言的格式化输出函数printf()，看到这样一句话”printf()函数是一个标准库函数，。。。它的函数原型在头文件stdio.h中”。脑子一抽，冒出一个想法。 猜想&emsp;&emsp;如果用户自定义了一个头文件stdio.h，程序会不会炸，还是用户自定义的stdio.h会覆盖库文件stdio.h。根据C语言中标识符中关键字为系统所有，不能被用户重定义和作为变量使用等，猜想程序可能会炸。 实践是检验真理的唯一标准&emsp;&emsp;于是写个小程序测试一下。&emsp;&emsp;源文件main.c代码如下： 123456789101112#include&lt;stdio.h&gt; //库文件，没有它，printf()函数就不能使用#include "stdio.h" //自定义头文件，没有它，max()函数不能使用int max(int,int);int main()&#123; int a,b,c; printf("请输入a,b值："); scanf("%d%d",&amp;a,&amp;b); c=max(a,b); printf("%d",c); return 0;&#125; &emsp;&emsp;头文件stdio.h代码如下： 1234int max(int a,int b)&#123; return a&gt;b?a:b;&#125; 运行结果： 请输入a,b值：11 311 请输入a,b值：3 1212 分析&emsp;&emsp;一开始，源文件中我并没写#include “stdio.h”这个预处理，结果炸了，当时想，哦，果然不能这么用。看了一下报错的错误：max没有被defined，也就是max()函数没有找到函数原型，于是试着填了#include “stdio.h”这句预处理，结果一跑对了！&emsp;&emsp;我猜测是因为：这和预处理中文件包含相关(见我的博客”C的预处理”)，文件包含有两种。#include&lt;&gt;尖括号中包含的文件，编译器会自动去库文件中寻找。而#include “”，双引号包含的文件，编译器会自动去工程项目所在的目录下去寻找。因此，这两个文件虽然重名，但是所在位置不一样，寻找方式不一样，这样就不是同一个文件，程序可以正常运行。nice!]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicat_premium12激活&Coding VS GitHub]]></title>
    <url>%2F2018%2F07%2F21%2Fnevicat_premium12%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这次实习呢，了解了很多有用的工具，比如神器：navicat premium。 Navicat Premium&emsp;&emsp;实习中我们使用的数据库是MySQL，功能也许不是那么完善强大，但是足够满足我们这些学生的使用。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择(摘自百度百科MySQL)。数据库无论是以前用的SQL Server还是实习中用的MySQL，对学生来讲几乎一样。让我眼前一亮的是工具：navicat premium。&emsp;&emsp;Navicat premium（详情见百度百科）是一款数据库管理工具。将此工具连接数据库，你可以从中看到各种数据库的详细信息。包括报错，等等。当然，你也可以通过他，登陆数据库，进行各种操作。Navicat Premium是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。 Navicat Premium破解的方法&emsp;&emsp;软件下载呢，还是要去官网。然后你就会发现它是收费的，只能试用14天，价格也是不菲的。&emsp;&emsp;没看错CNY9999.0，CNY在国际贸易中是表示人民币元的唯一规范符号，了解一下。但是不慌，总有热心的人提供破解的方法。&emsp;&emsp;破解的软件：可以在我的coding中下载项目navicat_premium。下载地址。&emsp;&emsp;破解步骤：下载完成后，就可以参照CSDN的一份博客来进行操作。CSDN地址。&emsp;&emsp;本人亲测有效。 GitHub VS Coding&emsp;&emsp;上面用的是我的coding，也是代码托管平台，之前一直用的GitHub。现在我渐渐习惯使用coding，原因有几个。 coding是中文的，比较亲民，它的所有菜单栏我大概了解是干什么的。emmmmm，本人英语水平不高。 GitHub服务器在外国，访问速度慢，经常访问失败。这我做过实验，同一份文档，上传到coding的速度明显比GitHub快。这也是我使用coding的主要原因。 然后就是因为这份文章，为什么 Coding 不是中国的 Github ?。 Can’t connect to MySQL server on localhost&emsp;&emsp;这是我在使用MySQL时遇到的一个问题。装完MySQL的第二天双击MySQL数据库就跳出标题的错误，几次都这样，明明第一天刚下用的好好的，怎么第二天就用不了了，一晚上睡过来就出事，就很气。终于在百度Google后找到了解决方案。原来时MySQL服务没有打开，需要手动开启。&emsp;&emsp;控制面板–&gt;管理工具–&gt;服务–&gt;mysql56–&gt;启动服务 。详细步骤。]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Workstation 14 Pro永久激活密钥]]></title>
    <url>%2F2018%2F06%2F26%2FVMware-Workstation-14-Pro%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;装虚拟机的话，VMware Workstation肯定是首选，毕竟强大如斯。 官网&emsp;&emsp;官网地址。还是那句话，下载软件请去官方网站。 VMware Workstation 14 Pro永久激活密钥&emsp;&emsp;现在最新版本是VMware Workstation 14。VMware Workstation 14 Pro不是免费的，只能试用一段时间。但是毕竟有好心人分享密钥。如下所示： CG54H-D8D0H-H8DHY-C6X7X-N2KG6 ZC3WK-AFXEK-488JP-A7MQX-XL8YF AC5XK-0ZD4H-088HP-9NQZV-ZG2R4 ZC5XK-A6E0M-080XQ-04ZZG-YF08D ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 &emsp;&emsp;亲测有效，有图为据。]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows+Ubuntu双系统删除Ubuntu]]></title>
    <url>%2F2018%2F05%2F12%2FWindows%2BUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4Ubuntu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近Ubuntu18.04版本发布了！加上之前在已经安装16.04版本瞎捣鼓，正好换个系统。之前是Windows+Ubuntu双系统，用起来有着诸多麻烦。这次就想把ubuntu系统删了，直接安装在虚拟机里。虽然这样不能充分利用电脑的内存资源，但是作为只是玩玩ubuntu的我还是追求方便，要是一不小心在ubuntu里弄坏了什么，虚拟机里可以直接删了再重装，很方便。趁这个机会，整理一下有关BIOS,Mbr,UEFI,Grub的资料。 按下开机键后发生了什么？&emsp;&emsp;第一次自己尝试捣鼓重装系统时，过程可以说是非常坎坷了，一下子就接触了好多新的专业词汇:BIOS,Mbr,UEFI和Grub等等。&emsp;&emsp;在了解BIOS之前，得看一看计算机的启动过程，在按下开机键后，我们的电脑到底做了哪些事。&emsp;&emsp;计算机的启动过程；&emsp;&emsp;BIOS(来自维基百科，翻墙可访问);&emsp;&emsp;一直叱咤风云的BIOS即将被UEFI BIOS淘汰，新主板将普及UEFI BIOS。&emsp;&emsp;UEFI(来自维基百科，翻墙可访问); Windows+Ubuntu双系统删除Ubuntu&emsp;&emsp;在安装双系统时，就要分清是BIOS还是UEFI了，因为需要根据不同情况选择方案去删除ubuntu这个系统。如果去磁盘直接删除安装ubuntu系统的分区，删完后还是Grub引导，开机的时候会发现进入了Grub的界面并不能进入Windows系统。&emsp;&emsp;UEFI启动Windows10+Ubuntu双系统删除Ubuntu方法；&emsp;&emsp;win10 gpt分区+uefi引导 卸载双系统ubuntu；&emsp;&emsp;EasyUEFI这款强大的软件请在官网下载。本着一个基本原则：所有软件都要在官方网站下载，绝不从什么下载之家、未来软件园下载。这些乱七八糟的网站下载的软件最可恶的就是给你绑定一套全家套软件套餐，毕竟它打广告是有报酬的，甚至软件并不完整，用起来出现什么bug，这影响就大了。最糟的情况就是带着木马病毒什么的，那就很爆炸了。所以所以所以下载软件什么的一定要做官网下！&emsp;&emsp;EasyUEFI官网]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Bios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的学习]]></title>
    <url>%2F2018%2F05%2F04%2FMarkdown%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Markdown 是一种电子邮件风格的标记语言。既然搭了博客网站，当然要写博客。我先在本地计算机用Markdown写好文章，再通过git部署到GitHub上的，然后在网页才会显示写的文章。Markdown的基本语法十分简单，一般五分钟就能学完日常基本所需的操作。 为什么选择Markdown&emsp;&emsp;既然写东西为什么不用微软的word,一开始我是有这样的疑惑的。搜了几篇文章后终于知道缘由了。&emsp;&emsp;为什么作家应该用 Markdown 保存自己的文稿。 Markdown教程&emsp;&emsp;献给写作者的 Markdown 新手指南;&emsp;&emsp;简单详细的教程;&emsp;&emsp;官方文档。&emsp;&emsp;看完这三篇基本上就差不多了，美滋滋。 高颜值神器Typora&emsp;&emsp;Typora是一款极致简洁的Markdown编辑器，谁用谁知道。Typora的官网。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git大法好]]></title>
    <url>%2F2018%2F04%2F27%2FGit%E5%A4%A7%E6%B3%95%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近搭博客，强势了解学习了一波git。以前只是注册了GitHub的账号，然后在上面拉一拉别人的代码，就没怎么深入学习了解。现在才发现git的强大美妙之处。现在整理一下这几天的所学习的东西，十分有趣。 git是什么？&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统(没有之一)。这么说可能有点官方，简单来讲git是一款软件，就像手机里的APP，手机的APP都具有相应的功能，git的功能是什么呢？它能帮我们做什么事情呢？ 版本控制系统？&emsp;&emsp;要理解git，就要先了解版本控制系统。见维基百科(只有翻墙了才能访问!)的详细解释。版本控制就我理解来讲：就是你新建一份文档或者一份代码，到最终完成它们，这个过程你一定经过不断修改，每次修改都会产生不同的版本，如图：你需要管理这些版本，有时候需要找回之前版本里的某些内容，这就是手工的版本控制了。手工版本控制工作量在开发大型项目时会十分的大，而且容易出错。所以“懒惰的”软件工程师们设计一款软件自动记录每个版本，你可以很轻松的知道你的文档何时创建的，一共经过几次修改，何时何人修改了什么，甚至可以地回退到某个修改的版本，这些功能只需要输入相应的命令就行。当然，这款软件的强大远不止我说的这些，这只是冰山一角！&emsp;&emsp;这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 文件名 用户 日期 1 论文.doc 张三 4/21 10:30 2 论文.doc 李四 4/22 11:30 3 论文.doc 张三 4/22 12:30 4 论文.doc 张三 4/23 10:30 &emsp;&emsp;这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的21世纪。 git的诞生&emsp;&emsp;很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？&emsp;&emsp;事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。&emsp;&emsp;不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。&emsp;&emsp;安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。&emsp;&emsp;Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。&emsp;&emsp;Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&emsp;&emsp;历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 人人都应该会用Git和GitHub&emsp;&emsp;之前在知乎上搜怎么使用GitHub，看到一个文科妹子的良心回复，详细的介绍了GitHub和为什么人人都应该会使用git和GitHub。给出链接：珊姗是个小太阳。 git的操作教程&emsp;&emsp;大致弄明白了git是什么了，以及它有趣的诞生史，就要真刀真枪的实干了，学习它的基本命令行操作了。这里强烈安利廖雪峰老师的教程。这个教程被称为史上最浅显易懂的教程，我承认它易懂，但一点也不浅显。根据这个教程我学到了git基本的命令行操作，终于可以用上git这款强大美妙的工具了，美滋滋。 快速上手教程&emsp;&emsp;如果只是上传代码到GitHub上，或者从GitHub上拉代码(这些几乎已经满足日常需要了)。点击快速上手教程。 细节问题&emsp;&emsp;用了一段时间的git，我发现：从GitHub上把远程仓库拉到本地，用git clone+地址的命令只能把整个项目全部拉下来，而有时我只需要这个项目的一份文件就行。解决方案：下载一个仓库的单个文件。 总结&emsp;&emsp;这篇博客我是4月27号开始写的，今天是5月4号青年节！其实这之间我每天晚上都在写，本来我是想展开成好几个篇来写的，但是今天突然回去看看了之前写的几篇。发现我把博客写成了教程，emmmmm，我写博客又不是来教别人怎么用，之前我把廖雪峰老师的教程几乎展开写了好几篇。突然发现我好傻，而且有抄袭的嫌疑。我写博客不就是记录自己学习某个东西的过程，以方便以后遗忘回来可以找到之前学习的轨迹和查阅的资料吗？差点走偏了，于是今晚就把学习git的过程中查阅的资料全都整理了一下，感觉这样就够了，这才是我写博客的目的。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C的预处理]]></title>
    <url>%2F2018%2F04%2F24%2FC%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;深入学习C的预处理。C/C++语言的程序第一行一般都是 #include “ “ 或者#include &lt; &gt;,以前只知道它是预处理，其中细节没有研究过。 现在从头再看一遍C，跟当初第一次学习C语言的感觉是完全不一样的（此处感慨省略一千字）。现在有能力深入研究一下C的预处理了，以此篇博客整理一下。 预处理&emsp;&emsp;首先在C/C++语言编译的时候，会经历以下几个步骤：预处理，编译，汇编，链接，然后生成可执行文件。整个过程是一连串动作完成的。而预处理阶段呢，也是最先执行的一个步骤。 定义 以“#”号开头的预处理指令如包含#include,宏定义制定#define等，在源程序中这些指令都放在函数之外，而且一般放在源文件里的最前面几行。预处理就是在对源程序的C代码进行编译之前所作的工作，预处理是C语言的一个重要的功能，它由预处理程序(预处理器)单独完成，当对一个源文件进行编译时，系统自动引用预处理程序，对源程序中的预处理进行一些文本性质的操作。简言之，C预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。 类型 1&gt;宏定义2&gt;条件编译3&gt;文件包含4&gt;预处理操作符#和##，预定义宏 任务 1&gt;将头文件中的内容(.h文件)插入到源文件中 2&gt;进行了宏替换的过程，定义和替换由#define指令定义的符号 3&gt;删除掉注释，注释是不会带入到编译阶段 4&gt;条件编译，根据“#if”后面的条件决定需要编译的代码 指令 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器 宏定义&emsp;&emsp;在C语言中允许用一个标识符来表示一个字符串：称为宏。在预处理时，对程序的宏进行替换。其中宏定义是由源程序中的#define来完成 ，而宏的替换，主要是由预处理程序完成。 1#define PI 3.14159 宏定义的规则 ’#‘表示一条预处理的指令，以’#‘开头的均是预处理指令 #define是宏定义的指令，标识符是所定义的宏名 宏名一般都是大写的字母表示，以便和变量名区别 宏定义其实并不是C语言的语句，所以后面是不用去加” ；“ 宏体可以是常数，表达式，格式化字符串等，为表达式的时候应该用括号括起来 宏替换不分配内存空间，也不做正确性的检查 宏的范围是从定义后到所在源文件结束，但是可以通过#undef来进行提前取消 无参数宏定义、有参数宏定义 无参数宏定义 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;/*无参数宏定义*/#define PI 3.14159#define A 123#define B "Hello World!"//#undef B //取消了宏B的定义，那么宏B就不能再程序中使用/*宏的移除语法#undef 宏名功能：删除前面定义的宏*/int main()&#123; int sum=1,R=2; float s; char str[20]; sum+=A; s=PI*R*R; strcpy(str,B); printf("sum=%d\n",sum); printf("半径为R圆的面积:%.2f\n",s); printf("输出字符串str:%s",str); return 0;&#125; 输出结果: sum=124半径为R圆的面积:12.57输出字符串str:Hello World! 带参数宏定义 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;/*带参数宏定义语法结构：#define [宏名](形参列表) (宏体)形式参数不分配内存单元，没有类型定义注：宏名和形式参数列表之间不能有空格出现。*//*MAX为宏名，紧跟其后(x,y)为形参列表，形参没有类型定义，((x) &gt; (y) ? (x) : (y))为宏体，是一个三目运算。*/#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))#define square(x) ((x) * (x))#define square_1(x) (x * x)int main()&#123; int a; a=MAX(3,5); printf("a=%d\n",a); //宏的本质是直接代入替换参数的位置,文本替换 printf("square(5+4) is %d\n", square(5+4)); //(5+4)*(5+4)=81 printf("square_1(5+4) is %d\n", square_1(5+4)); //5+4*5+4=29 return 0;&#125; 输出结果: a=5square(5+4) is 81square_1(5+4) is 29 从带有参数的宏定义，可以看出在很多场合下，宏可以当成函数使用，但是又和真正的函数是有区别的。区别如下图所示： 对比项 带参数宏定义 函数 处理时间 编译时期 程序运行时期 参数类型 无参数类型 有具体的参数类型 处理过程 不分配内存，简单字符的置换 分配内存，先求得实参，再传递给形参 程序长度 会变长 不变 运行速度 不会占用运行时间 调用和返回会占用时间 支持递归 不支持 支持 条件编译 概念 一般情况下，源程序中所有的行都进行编译，但是有时希望对其中一部分内容满足一定条件下才进行编译，也就是对一部分内容指定编译条件，这就是条件编译。 优点 条件编译可以指定代码的一部分是被正常编译还是被完全忽略 ,条件编译有利于提升程序的可移植性，增强程序 的灵活性。 语法 编译语法一： 1234567891011#ifdef 标识符(宏名) //或者#if define(标识符) 程序段1 #else 程序段2 #endif 实例：防止多重包含的问题产生#define HELLO "helloworld"#ifdef HELLO #define HI "welcome"#endif 编译语法二： 12345678910111213#ifndef 标识符（宏名） //或#if !define(标识符) 程序段1 #else 程序段2 #endif实例：#ifndef __HELLO_H__ #define __HELLO_H__ void out();#else //程序段2#endif 编译语法三： 123456789101112131415161718192021#if(常量表达式) 程序段1#elif(常量表达式2) 程序段2 #else 程序段3 #endif实例代码：#define C1 0#define C2 0 #define C3 1#if(C1) #include "c1.h"#elif(C2) #include "c2.h"#elif(C3) #include "c3.h"#else #include "c.h"#endif 文件包含 概念 文件包含是C预处理程序的另一个重要的功能，被包含的文件名字必须使用双引号” “(自定义头文件)，或者&lt; &gt;(标准库文件)括起来。例如：#include&lt;math.h&gt;,#include “myfunction.h”。 功能 一个源文件可以将另外一个源文件的内容包含进来，从而把指定的文件和当前的源文件连成一个源文件。 文件包含的处理过程： 在预处理的时候，用被包含文件的内容取代该文件包含指令，再对包含后的文件作一个源文件编译。 文件多重包含问题 概念：同一个文件被包含多次 结果：多重包含可能会出现重复定义的编译错误 解决方案：使用条件编译来防止多重包含,凡是在头文件前后，用条件编译去编译。 123456//如标准头文件的写法：#ifndef __HEADER_NAME_H__#define __HEADER_NAME_H__#include "headername.h"//其他的代码#endif 建议：在头文件中尽量不要去定义一些全局变量，可以在源文件中去定义，用extern去修饰。extern的用法。 预处理操作符和预定义宏 预处理操作符&emsp;&emsp;C语言中有两个预处理操作符号#。操作符号#通常成为字符串化的操作符号，它把其后的串变成用双引号包围的串。连接操作符号##可以把两个独立的字符串链接成一个字符串。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//一个宏通常写在一个单行上.但是如果宏太长,//一个单行容纳不下，则使用宏延续运算符"\"//当需要把一个宏的参数转换为字符串常量时,则使用字符串常量化运算符"#"#define message_for(a,b) \ printf(#a " and " #b ":We love you!\n")//宏定义内的标记粘贴运算符"##"会合并两个参数.//它允许在宏定义中两个独立的标记被合并为一个标记//这里的token##n=token+n,而n在main()里是34,so token##n=token34=40#define tokenpaster(n) printf("token" #n " = %d\n", token##n)int main()&#123; message_for(Java,Python); int token34 = 40; tokenpaster(34); return 0;&#125; 输出结果： Java and Python:We love you!token34 = 40 预定义宏&emsp;&emsp;ANSI C 定义了许多宏。在编程中你直接可以使用这些宏，但是不能直接修改这些预定义的宏。 123456789101112131415161718#include &lt;stdio.h&gt;int func(int a)&#123; printf("Function :%s\n",__FUNCTION__); //当前所在的函数名称 return 0;&#125;int main()&#123; printf("File :%s\n", __FILE__ ); //当前文件名，一个字符串常量。 printf("Date :%s\n", __DATE__ ); //当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 printf("Time :%s\n", __TIME__ ); //当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。 printf("Line :%d\n", __LINE__ ); //这会包含当前行号，一个十进制常量。 printf("ANSI :%d\n", __STDC__ ); //当编译器以 ANSI 标准编译时，则定义为 1 func(1); return 0;&#125; 输出结果： File :C:\a1-C\Test\main.cDate :Apr 28 2018Time :10:35:28Line :14ANSI :1Function :func]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+GitHub+next搭建博客]]></title>
    <url>%2F2018%2F04%2F22%2Fhexo%2BGitHub%2Bnext%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很久之前就想搭个属于自己的独立的博客，最近终于付之于行动了。这几天在网上了找了很多相关的资料，了解到了用hexo+github的方法搭建一个简便的博客。把这几天找到有用的网站整理一下，方便以后再深入了解。 基于windows系统的基本环境配置环境 需要安装的软件：Node.js和Git 注册Github账号，创建代码库，部署本地文件到GitHub 安装Hexo 初始化Hexo,首次体验Hexo 更换主题&emsp;&emsp;首次体验的Hexo主题是默认的，网站上有很多好看的主题。我选的主题是:next。在很多的主题中非常喜欢这个，简单大气，又功能俱全。接下来贴出next主题的相关配置链接。 首先是官方文档 官方文档比较全面但不详细，可以对照着看，具体操作还得看其他博主的博客基础配置 基础配置过后就可以来升级版了，让自己的博客具有更多的功能从而更好看升级配置 再补充一个偶然看到标签云的高级配置标签云这个也是有官方文档 在使用next主题前，我是使用Yelee主题的，我感觉next主题更好一点，不过萝卜白菜各有所爱。这里贴出Yelee主题的使用说明 注册域名&emsp;&emsp;在腾讯云买了域名，就像在淘宝买东西一样，输入自己想要的域名(例如：abc.cn、abc.com等等)，只要之前没人注册过，然后下单付钱。之后需要实名认证，实名认证的认证需要2到3个工作日。等实名认证通过了，你就可以解析域名了。可以自己购买服务器，将域名解析，也可以不花一分钱的可以直接绑定到GitHub上(富人靠金币，穷人靠科技，hhhhh)。操作步骤： 1、在你的域名管理有一个解析的选项，添加两条记录类型为CNAME的解析，一条主机记录为@，一条主机记录为www，记录值都为你的格式为username.github.io的地址。 2、在你的本地hexo博客文件的source文件夹下创建一个CNAME文件，记住不要有文件后缀名。编辑CNAME文件，里面写你在第一步申请的域名，例如：xxxx.cn，记住不要有www。3、在你本地博客文件里运行hexo g，再运行hexo d。4、在浏览器输入你申请的域名，你会发现该域名已经指向了你在github上的博客了。ps：设置域名解析需要几分钟的时间，完成以上步骤依然无法访问，请过几分钟再尝试访问。 补充&emsp;&emsp;在之后的使用中发现浏览器的留白太多，导致博客文章宽度不够，代码的查阅十分不方便。解决方案：next/source/css/_variables/custom.styl文件中添加 $main-desktop = 1200px $content-desktop = 900px 最后&emsp;&emsp;现在终于有一个独立域名的博客:computerkid.cn。弄了快两个星期，不过百度和Google并没有收录，现在也不急，目前就当做自己个人的日记一样，直接在浏览器输入网址就行。收录的问题。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Welcome to My Blog！ 我搭建博客的目的：&emsp;&emsp;记录平时学习的东西、解决的问题、浏览的有趣的网站等等，做一个总结和整理，方便以后还能找到。一切都是兴趣使然！ 强烈推荐阅读： 书写是为了更好的思考 为什么你应该(从现在开始就)写博客 123456//C#include &lt;stdio.h&gt;int main()&#123; printf("Hello World!")&#125; 1234567//C++#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl;&#125; 12345678910//Javapublic class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println("Hello World"); &#125;&#125; 12#Pythonprint("Hello World")]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
