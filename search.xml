<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git大法好(一)：git诞生的有趣历史]]></title>
    <url>%2F2018%2F04%2F27%2FGit%E5%A4%A7%E6%B3%95%E5%A5%BD(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[最近搭博客，强势了解学习了一波git。以前只是注册了GitHub的账号，然后在上面拉一拉别人的代码，就没怎么深入学习了解。现在才发现git的强大美妙之处。现在整理一下这几天的所学习的东西，从git的诞生开始，十分有趣。 1、git是什么？Git是目前世界上最先进的分布式版本控制系统(没有之一)。 2、git的有什么特点？简单来说就是：高端大气上档次！！！ 3、那什么是版本控制系统？如果你用Word写过一个很长的论文，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件复制粘贴另存为一个新的Word文件，再接着改，改到一定程度，再复制粘贴另存为一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。你可能还要给导师看看是否需要修改，于是你把文件复制到U盘里给他(也可能通过Email发送一份给他)。然后，你继续修改Word文件。一天后，导师再把Word文件传给你，此时，你必须想想，发给他之后到你收到他的文件期间，你作了哪些改动，得把你的改动和他的部分合并，真困难。于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让导师协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 文件名 用户 日期 1 论文.doc 张三 4/21 10:30 2 论文.doc 李四 4/22 11:30 3 论文.doc 张三 4/22 12:30 4 论文.doc 张三 4/23 10:30 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的21世纪。 4、git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 5、人人都应该会用Git和GitHub之前在知乎上搜怎么使用GitHub，看到一个文科妹子的良心回复，详细的介绍了GitHub和为什么人人都应该会使用git和GitHub。给出链接：珊姗是个小太阳]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C的预处理]]></title>
    <url>%2F2018%2F04%2F24%2FC%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[深入学习C的预处理。C/C++语言的程序第一行一般都是 #include “ “ 或者#include &lt; &gt;,以前只知道它是预处理，其中细节没有研究过。 现在从头再看一遍C，跟当初第一次学习C语言的感觉是完全不一样的（此处感慨省略一千字）。现在有能力深入研究一下C的预处理了，以此篇博客整理一下。 1、预处理首先在C/C++语言编译的时候，会经历以下几个步骤：预处理，编译，汇编，链接，然后生成可执行文件。整个过程是一连串动作完成的。而预处理阶段呢，也是最先执行的一个步骤。 定义 以“#”号开头的预处理指令如包含#include,宏定义制定#define等，在源程序中这些指令都放在函数之外，而且一般放在源文件里的最前面几行。预处理就是在对源程序的C代码进行编译之前所作的工作，预处理是C语言的一个重要的功能，它由预处理程序(预处理器)单独完成，当对一个源文件进行编译时，系统自动引用预处理程序，对源程序中的预处理进行一些文本性质的操作。简言之，C预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。 类型 1&gt;宏定义2&gt;条件编译3&gt;文件包含4&gt;预处理操作符#和##，预定义宏 任务 1&gt;将头文件中的内容(.h文件)插入到源文件中 2&gt;进行了宏替换的过程，定义和替换由#define指令定义的符号 3&gt;删除掉注释，注释是不会带入到编译阶段 4&gt;条件编译，根据“#if”后面的条件决定需要编译的代码 指令 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器 2、宏定义在C语言中允许用一个标识符来表示一个字符串：称为宏。在预处理时，对程序的宏进行替换。其中宏定义是由源程序中的#define来完成 ，而宏的替换，主要是由预处理程序完成。 1#define PI 3.14159 宏定义的规则 ’#‘表示一条预处理的指令，以’#‘开头的均是预处理指令 #define是宏定义的指令，标识符是所定义的宏名 宏名一般都是大写的字母表示，以便和变量名区别 宏定义其实并不是C语言的语句，所以后面是不用去加” ；“ 宏体可以是常数，表达式，格式化字符串等，为表达式的时候应该用括号括起来 宏替换不分配内存空间，也不做正确性的检查 宏的范围是从定义后到所在源文件结束，但是可以通过#undef来进行提前取消 无参数宏定义、有参数宏定义 无参数宏定义 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;/*无参数宏定义*/#define PI 3.14159#define A 123#define B "Hello World!"//#undef B //取消了宏B的定义，那么宏B就不能再程序中使用/*宏的移除语法#undef 宏名功能：删除前面定义的宏*/int main()&#123; int sum=1,R=2; float s; char str[20]; sum+=A; s=PI*R*R; strcpy(str,B); printf("sum=%d\n",sum); printf("半径为R圆的面积:%.2f\n",s); printf("输出字符串str:%s",str); return 0;&#125; 输出结果: sum=124半径为R圆的面积:12.57输出字符串str:Hello World! 带参数宏定义 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;/*带参数宏定义语法结构：#define [宏名](形参列表) (宏体)形式参数不分配内存单元，没有类型定义注：宏名和形式参数列表之间不能有空格出现。*//*MAX为宏名，紧跟其后(x,y)为形参列表，形参没有类型定义，((x) &gt; (y) ? (x) : (y))为宏体，是一个三目运算。*/#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))#define square(x) ((x) * (x))#define square_1(x) (x * x)int main()&#123; int a; a=MAX(3,5); printf("a=%d\n",a); //宏的本质是直接代入替换参数的位置,文本替换 printf("square(5+4) is %d\n", square(5+4)); //(5+4)*(5+4)=81 printf("square_1(5+4) is %d\n", square_1(5+4)); //5+4*5+4=29 return 0;&#125; 输出结果: a=5square(5+4) is 81square_1(5+4) is 29 从带有参数的宏定义，可以看出在很多场合下，宏可以当成函数使用，但是又和真正的函数是有区别的。区别如下图所示： 对比项 带参数宏定义 函数 处理时间 编译时期 程序运行时期 参数类型 无参数类型 有具体的参数类型 处理过程 不分配内存，简单字符的置换 分配内存，先求得实参，再传递给形参 程序长度 会变长 不变 运行速度 不会占用运行时间 调用和返回会占用时间 支持递归 不支持 支持 3、条件编译 概念 一般情况下，源程序中所有的行都进行编译，但是有时希望对其中一部分内容满足一定条件下才进行编译，也就是对一部分内容指定编译条件，这就是条件编译。 优点 条件编译可以指定代码的一部分是被正常编译还是被完全忽略 ,条件编译有利于提升程序的可移植性，增强程序 的灵活性。 语法 编译语法一： 1234567891011#ifdef 标识符(宏名) //或者#if define(标识符) 程序段1 #else 程序段2 #endif 实例：防止多重包含的问题产生#define HELLO "helloworld"#ifdef HELLO #define HI "welcome"#endif 编译语法二： 12345678910111213#ifndef 标识符（宏名） //或#if !define(标识符) 程序段1 #else 程序段2 #endif实例：#ifndef __HELLO_H__ #define __HELLO_H__ void out();#else //程序段2#endif 编译语法三： 123456789101112131415161718192021#if(常量表达式) 程序段1#elif(常量表达式2) 程序段2 #else 程序段3 #endif实例代码：#define C1 0#define C2 0 #define C3 1#if(C1) #include "c1.h"#elif(C2) #include "c2.h"#elif(C3) #include "c3.h"#else #include "c.h"#endif 4、文件包含 概念 文件包含是C预处理程序的另一个重要的功能，被包含的文件名字必须使用双引号” “(自定义头文件)，或者&lt; &gt;(标准库文件)括起来。例如：#include&lt;math.h&gt;,#include “myfunction.h”。 功能 一个源文件可以将另外一个源文件的内容包含进来，从而把指定的文件和当前的源文件连成一个源文件。 文件包含的处理过程： 在预处理的时候，用被包含文件的内容取代该文件包含指令，再对包含后的文件作一个源文件编译。 文件多重包含问题 概念：同一个文件被包含多次 结果：多重包含可能会出现重复定义的编译错误 解决方案：使用条件编译来防止多重包含,凡是在头文件前后，用条件编译去编译。 123456//如标准头文件的写法：#ifndef __HEADER_NAME_H__#define __HEADER_NAME_H__#include "headername.h"//其他的代码#endif 建议：在头文件中尽量不要去定义一些全局变量，可以在源文件中去定义，用extern去修饰。extern的用法。 5、预处理操作符和预定义宏 预处理操作符C语言中有两个预处理操作符号#。操作符号#通常成为字符串化的操作符号，它把其后的串变成用双引号包围的串。连接操作符号##可以把两个独立的字符串链接成一个字符串。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//一个宏通常写在一个单行上.但是如果宏太长,//一个单行容纳不下，则使用宏延续运算符"\"//当需要把一个宏的参数转换为字符串常量时,则使用字符串常量化运算符"#"#define message_for(a,b) \ printf(#a " and " #b ":We love you!\n")//宏定义内的标记粘贴运算符"##"会合并两个参数.//它允许在宏定义中两个独立的标记被合并为一个标记//这里的token##n=token+n,而n在main()里是34,so token##n=token34=40#define tokenpaster(n) printf("token" #n " = %d\n", token##n)int main()&#123; message_for(Java,Python); int token34 = 40; tokenpaster(34); return 0;&#125; 输出结果： Java and Python:We love you!token34 = 40 预定义宏ANSI C 定义了许多宏。在编程中你直接可以使用这些宏，但是不能直接修改这些预定义的宏。 123456789101112131415161718#include &lt;stdio.h&gt;int func(int a)&#123; printf("Function :%s\n",__FUNCTION__); //当前所在的函数名称 return 0;&#125;int main()&#123; printf("File :%s\n", __FILE__ ); //当前文件名，一个字符串常量。 printf("Date :%s\n", __DATE__ ); //当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 printf("Time :%s\n", __TIME__ ); //当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。 printf("Line :%d\n", __LINE__ ); //这会包含当前行号，一个十进制常量。 printf("ANSI :%d\n", __STDC__ ); //当编译器以 ANSI 标准编译时，则定义为 1 func(1); return 0;&#125; 输出结果： File :C:\a1-C\Test\main.cDate :Apr 28 2018Time :10:35:28Line :14ANSI :1Function :func]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+GitHub+next搭建博客]]></title>
    <url>%2F2018%2F04%2F22%2Fhexo%2BGitHub%2Bnext%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[很久之前就想搭个属于自己的独立的博客，最近终于付之于行动了。这几天在网上了找了很多相关的资料，了解到了用hexo+github的方法搭建一个简便的博客。把这几天找到有用的网站整理一下，方便以后再深入了解。 1、基于windows系统的基本环境配置环境 需要安装的软件：Node.js和Git 注册Github账号，创建代码库，部署本地文件到GitHub 安装Hexo 初始化Hexo,首次体验Hexo 2、更换主题首次体验的Hexo主题是默认的，网站上有很多好看的主题。我选的主题是:next。在很多的主题中非常喜欢这个，简单大气，又功能俱全。接下来贴出next主题的相关配置链接。 首先是官方文档 官方文档比较全面但不详细，可以对照着看，具体操作还得看其他博主的博客基础配置 基础配置过后就可以来升级版了，让自己的博客具有更多的功能从而更好看升级配置 再补充一个偶然看到标签云的高级配置标签云这个也是有官方文档 在使用next主题前，我是使用Yelee主题的，我感觉next主题更好一点，不过萝卜白菜各有所爱。这里贴出Yelee主题的使用说明 3、注册域名在腾讯云买了域名，就像在淘宝买东西一样，输入自己想要的域名(例如：abc.cn、abc.com等等)，只要之前没人注册过，然后下单付钱。之后需要实名认证，实名认证的认证需要2到3个工作日。等实名认证通过了，你就可以解析域名了。可以自己购买服务器，将域名解析，也可以不花一分钱的可以直接绑定到GitHub上(富人靠金币，穷人靠科技，hhhhh)。 操作步骤： 1、在你的域名管理有一个解析的选项，添加两条记录类型为CNAME的解析，一条主机记录为@，一条主机记录为www，记录值都为你的格式为username.github.io的地址。 2、.在你的本地hexo博客文件的source文件夹下创建一个CNAME文件，记住不要有文件后缀名。编辑CNAME文件，里面写你在第一步申请的域名，例如：xxxx.cn，记住不要有www。3、在你本地博客文件里运行hexo g，再运行hexo d。4、在浏览器输入你申请的域名，你会发现该域名已经指向了你在github上的博客了。ps：设置域名解析需要几分钟的时间，完成以上步骤依然无法访问，请过几分钟再尝试访问。 4、补充在之后的使用中发现浏览器的留白太多，导致博客文章宽度不够，代码的查阅十分不方便。解决方案：next/source/css/_variables/custom.styl文件中添加 $main-desktop = 1200px $content-desktop = 900px 5、最后现在终于有一个独立域名的博客:computerkid.cn。弄了快两个星期，不过百度和Google并没有收录，现在也不急，目前就当做自己个人的日记一样，直接在浏览器输入网址就行。收录的问题。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to MyBlog 1、我搭建博客的目的：记录平时学习的东西、解决的问题、浏览的有趣的网站等等，做一个总结和整理，方便以后还能找到。一切都是兴趣使然！ 2、强烈推荐阅读： 书写是为了更好的思考 为什么你应该(从现在开始就)写博客 123456//C#include &lt;stdio.h&gt;int main()&#123; printf("Hello World!")&#125; 1234567//C++#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl;&#125; 12345678910//Javapublic class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println("Hello World"); &#125;&#125; 12#Pythonprint("Hello World")]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
