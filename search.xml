<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git大法好(三)：git的实际操作]]></title>
    <url>%2F2018%2F05%2F03%2FGit%E5%A4%A7%E6%B3%95%E5%A5%BD(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一开始学习git时，最困难的就是git到底是什么，经过很多天的查阅资料，终于大致弄明白了。正所谓万事开头难，搞懂了git是什么，git是用来的做什么的，那么git的实际操作就很容易学习和上手了。这里强烈安利[廖雪峰老师的git教程] ###]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git大法好(二)：集中式VS分布式]]></title>
    <url>%2F2018%2F04%2F28%2FGit%E5%A4%A7%E6%B3%95%E5%A5%BD(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;进一步了解版本控制系统。git大法好(一)初步了解了一下什么是git以及版本控制系统。接下来详细介绍一下版本控制系统，这样才能真正的理解git到底是什么。 1.什么是版本控制？&emsp;&emsp;维基百科(只有翻墙了才能访问)上有详细的资料版本控制。简单地概括一下重点部分。 1.1定义&emsp;&emsp;版本控制（Revision control）是维护工程蓝图的标准做法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一代码文件案都得到同步。 1.2概述&emsp;&emsp;通过文档控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号。一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推。最简单的例子是，最初的版本指定为“1”，当做了改变之后，版本编号增加为“2”，以此类推。借此，版本控制能提供项目的设计者，将设计恢复到之前任一状态的选择权，这种选择权在设计过程进入死胡同时特别重要。理论上所有的信息记录都可以加上版本控制，在过去的实务中，除了软件开发的流程，其它的领域中很少有使用较复杂的版本控制技巧与工具（虽然可能为其带来许多好处）。目前已有人开始用版本控制软件来管理CAD电子文件，电路板设计，来补足本来由人手工运行的传统版本控制。 1.3软件版本控制&emsp;&emsp;软件设计师常会利用版本控制来追踪、维护源码、文件以及配置文件等等的改动，并且提供控制这些改动权利的程序。在最简单的情况下，软件设计师可以自己保留一个程序的许多不同版本，并且为它们做适当的编号。这种简单的方法已被用在很多大型的软件项目中。该方法虽然可行，但不够有效率。除了必须同时维护很多几乎一样的源码备分外；而且极度依赖软件设计师的自我修养与开发纪律，但这却常是导致错误发生的原因。&emsp;&emsp;有时候，一个程序同时存有两个以上的版本也有其必要性，例如：一个已经发布的版本中程序错误已经被修正、但没有加入新功能；而另一个开发版本则有新的功能正在开发、也有新的错误待解决，这使得同时间需要不同的版本并修改。&emsp;&emsp;此外，为了找出只存在于某一特定版本中（为了修正了某些问题、或新加功能所导致）的程序错误、或找出程序错误出现的版本，软件除错者也必须比对不同版本的代码以找出问题的位置。 1.4软件版本的控制方法&emsp;&emsp;最简单的版本控制就是保留软件不同版本的数份副本，并且适当编号。许多大型开发案都是使用这种简单技巧。虽然这种方法能用，但是很没效率。一是因为保存的数份副本几乎完全一样，也因为这种方法要高度依靠开发者的自我纪律，而常导致错误。因此，开发出了将部分或全部版本控制工作自动化的版本控制系统。 2.集中式VS分布式&emsp;&emsp;自动化的版本控制系统主要分为两类：集中式和分布式。前面说到的Linus大佬一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？&emsp;&emsp;先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。&emsp;&emsp;集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。&emsp;&emsp;那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。&emsp;&emsp;在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。&emsp;&emsp;当然，Git的优势不单是不必联网这么简单，Git极其强大的分支管理，把SVN等远远抛在了后面。CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase，特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。&emsp;&emsp;分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 3. 总结&emsp;&emsp;版本控制版本控制，由字面意思就可以的知道个大概，就是一份代码或者文档从创建开始到最终完成，这个过程不中断修改而产生了不同的版本，对这些版本进行控制。以前是人工手动操作，效率不高且容易出现失误，所以人们设计了一款自动控制的软件。而一开始这款软件对版本控制采用的是集中式，集中式在长时间的使用过程中暴露出了一系列问题。然后有一个叫Linus的大佬横空出世，花两周的时间开发了一个分布式版本控制系统:Git。从而造福现在的程序员们甚至更广泛的人们。Git是个很强大很神奇的工具，所以我写这些博客记录自己的学习的过程。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git大法好(一)：git有趣的诞生史]]></title>
    <url>%2F2018%2F04%2F27%2FGit%E5%A4%A7%E6%B3%95%E5%A5%BD(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近搭博客，强势了解学习了一波git。以前只是注册了GitHub的账号，然后在上面拉一拉别人的代码，就没怎么深入学习了解。现在才发现git的强大美妙之处。现在整理一下这几天的所学习的东西，从git的诞生开始，十分有趣。 1、git是什么？&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统(没有之一)。这么说可能有点官方，现在只要知道git是一款软件就行了，就像手机里的APP，后面的博客会详细谈谈版本控制系统。手机的APP都具有相应的功能，git的功能是什么呢？它能帮我们做什么事情呢？ 2、git的有什么特点？&emsp;&emsp;简单来说就是：高端大气上档次！！！ 3、首先谈谈什么是版本控制系统？&emsp;&emsp;如果你用Word写过一个很长的论文，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件复制粘贴另存为一个新的Word文件，再接着改，改到一定程度，再复制粘贴另存为一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。你可能还要给导师看看是否需要修改，于是你把文件复制到U盘里给他(也可能通过Email发送一份给他)。然后，你继续修改Word文件。一天后，导师再把Word文件传给你，此时，你必须想想，发给他之后到你收到他的文件期间，你作了哪些改动，得把你的改动和他的部分合并，真困难。于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让导师协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便。&emsp;&emsp;这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 文件名 用户 日期 1 论文.doc 张三 4/21 10:30 2 论文.doc 李四 4/22 11:30 3 论文.doc 张三 4/22 12:30 4 论文.doc 张三 4/23 10:30 &emsp;&emsp;这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的21世纪。这样解释的话，差不多理解git这款软件是干什么的吧，简单来讲就是智能的管理一份需要经常修改，或者多人合作修改的文档啊，代码啊等等。通过git你可以很轻松的知道你的文档何时创建的，一共经过几次修改，何时何人修改了什么，甚至可以轻松地回退到某个修改的版本。当然它的强大远不止我说的这些，这只是冰山一角。更多的后面我会慢慢写出来。 4、git的诞生&emsp;&emsp;很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？&emsp;&emsp;事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。&emsp;&emsp;不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。&emsp;&emsp;安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。&emsp;&emsp;Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。&emsp;&emsp;Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&emsp;&emsp;历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 5、人人都应该会用Git和GitHub&emsp;&emsp;之前在知乎上搜怎么使用GitHub，看到一个文科妹子的良心回复，详细的介绍了GitHub和为什么人人都应该会使用git和GitHub。给出链接：珊姗是个小太阳。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C的预处理]]></title>
    <url>%2F2018%2F04%2F24%2FC%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;深入学习C的预处理。C/C++语言的程序第一行一般都是 #include “ “ 或者#include &lt; &gt;,以前只知道它是预处理，其中细节没有研究过。 现在从头再看一遍C，跟当初第一次学习C语言的感觉是完全不一样的（此处感慨省略一千字）。现在有能力深入研究一下C的预处理了，以此篇博客整理一下。 1、预处理&emsp;&emsp;首先在C/C++语言编译的时候，会经历以下几个步骤：预处理，编译，汇编，链接，然后生成可执行文件。整个过程是一连串动作完成的。而预处理阶段呢，也是最先执行的一个步骤。 定义 以“#”号开头的预处理指令如包含#include,宏定义制定#define等，在源程序中这些指令都放在函数之外，而且一般放在源文件里的最前面几行。预处理就是在对源程序的C代码进行编译之前所作的工作，预处理是C语言的一个重要的功能，它由预处理程序(预处理器)单独完成，当对一个源文件进行编译时，系统自动引用预处理程序，对源程序中的预处理进行一些文本性质的操作。简言之，C预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。 类型 1&gt;宏定义2&gt;条件编译3&gt;文件包含4&gt;预处理操作符#和##，预定义宏 任务 1&gt;将头文件中的内容(.h文件)插入到源文件中 2&gt;进行了宏替换的过程，定义和替换由#define指令定义的符号 3&gt;删除掉注释，注释是不会带入到编译阶段 4&gt;条件编译，根据“#if”后面的条件决定需要编译的代码 指令 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器 2、宏定义&emsp;&emsp;在C语言中允许用一个标识符来表示一个字符串：称为宏。在预处理时，对程序的宏进行替换。其中宏定义是由源程序中的#define来完成 ，而宏的替换，主要是由预处理程序完成。 1#define PI 3.14159 宏定义的规则 ’#‘表示一条预处理的指令，以’#‘开头的均是预处理指令 #define是宏定义的指令，标识符是所定义的宏名 宏名一般都是大写的字母表示，以便和变量名区别 宏定义其实并不是C语言的语句，所以后面是不用去加” ；“ 宏体可以是常数，表达式，格式化字符串等，为表达式的时候应该用括号括起来 宏替换不分配内存空间，也不做正确性的检查 宏的范围是从定义后到所在源文件结束，但是可以通过#undef来进行提前取消 无参数宏定义、有参数宏定义 无参数宏定义 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;/*无参数宏定义*/#define PI 3.14159#define A 123#define B "Hello World!"//#undef B //取消了宏B的定义，那么宏B就不能再程序中使用/*宏的移除语法#undef 宏名功能：删除前面定义的宏*/int main()&#123; int sum=1,R=2; float s; char str[20]; sum+=A; s=PI*R*R; strcpy(str,B); printf("sum=%d\n",sum); printf("半径为R圆的面积:%.2f\n",s); printf("输出字符串str:%s",str); return 0;&#125; 输出结果: sum=124半径为R圆的面积:12.57输出字符串str:Hello World! 带参数宏定义 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;/*带参数宏定义语法结构：#define [宏名](形参列表) (宏体)形式参数不分配内存单元，没有类型定义注：宏名和形式参数列表之间不能有空格出现。*//*MAX为宏名，紧跟其后(x,y)为形参列表，形参没有类型定义，((x) &gt; (y) ? (x) : (y))为宏体，是一个三目运算。*/#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))#define square(x) ((x) * (x))#define square_1(x) (x * x)int main()&#123; int a; a=MAX(3,5); printf("a=%d\n",a); //宏的本质是直接代入替换参数的位置,文本替换 printf("square(5+4) is %d\n", square(5+4)); //(5+4)*(5+4)=81 printf("square_1(5+4) is %d\n", square_1(5+4)); //5+4*5+4=29 return 0;&#125; 输出结果: a=5square(5+4) is 81square_1(5+4) is 29 从带有参数的宏定义，可以看出在很多场合下，宏可以当成函数使用，但是又和真正的函数是有区别的。区别如下图所示： 对比项 带参数宏定义 函数 处理时间 编译时期 程序运行时期 参数类型 无参数类型 有具体的参数类型 处理过程 不分配内存，简单字符的置换 分配内存，先求得实参，再传递给形参 程序长度 会变长 不变 运行速度 不会占用运行时间 调用和返回会占用时间 支持递归 不支持 支持 3、条件编译 概念 一般情况下，源程序中所有的行都进行编译，但是有时希望对其中一部分内容满足一定条件下才进行编译，也就是对一部分内容指定编译条件，这就是条件编译。 优点 条件编译可以指定代码的一部分是被正常编译还是被完全忽略 ,条件编译有利于提升程序的可移植性，增强程序 的灵活性。 语法 编译语法一： 1234567891011#ifdef 标识符(宏名) //或者#if define(标识符) 程序段1 #else 程序段2 #endif 实例：防止多重包含的问题产生#define HELLO "helloworld"#ifdef HELLO #define HI "welcome"#endif 编译语法二： 12345678910111213#ifndef 标识符（宏名） //或#if !define(标识符) 程序段1 #else 程序段2 #endif实例：#ifndef __HELLO_H__ #define __HELLO_H__ void out();#else //程序段2#endif 编译语法三： 123456789101112131415161718192021#if(常量表达式) 程序段1#elif(常量表达式2) 程序段2 #else 程序段3 #endif实例代码：#define C1 0#define C2 0 #define C3 1#if(C1) #include "c1.h"#elif(C2) #include "c2.h"#elif(C3) #include "c3.h"#else #include "c.h"#endif 4、文件包含 概念 文件包含是C预处理程序的另一个重要的功能，被包含的文件名字必须使用双引号” “(自定义头文件)，或者&lt; &gt;(标准库文件)括起来。例如：#include&lt;math.h&gt;,#include “myfunction.h”。 功能 一个源文件可以将另外一个源文件的内容包含进来，从而把指定的文件和当前的源文件连成一个源文件。 文件包含的处理过程： 在预处理的时候，用被包含文件的内容取代该文件包含指令，再对包含后的文件作一个源文件编译。 文件多重包含问题 概念：同一个文件被包含多次 结果：多重包含可能会出现重复定义的编译错误 解决方案：使用条件编译来防止多重包含,凡是在头文件前后，用条件编译去编译。 123456//如标准头文件的写法：#ifndef __HEADER_NAME_H__#define __HEADER_NAME_H__#include "headername.h"//其他的代码#endif 建议：在头文件中尽量不要去定义一些全局变量，可以在源文件中去定义，用extern去修饰。extern的用法。 5、预处理操作符和预定义宏 预处理操作符&emsp;&emsp;C语言中有两个预处理操作符号#。操作符号#通常成为字符串化的操作符号，它把其后的串变成用双引号包围的串。连接操作符号##可以把两个独立的字符串链接成一个字符串。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//一个宏通常写在一个单行上.但是如果宏太长,//一个单行容纳不下，则使用宏延续运算符"\"//当需要把一个宏的参数转换为字符串常量时,则使用字符串常量化运算符"#"#define message_for(a,b) \ printf(#a " and " #b ":We love you!\n")//宏定义内的标记粘贴运算符"##"会合并两个参数.//它允许在宏定义中两个独立的标记被合并为一个标记//这里的token##n=token+n,而n在main()里是34,so token##n=token34=40#define tokenpaster(n) printf("token" #n " = %d\n", token##n)int main()&#123; message_for(Java,Python); int token34 = 40; tokenpaster(34); return 0;&#125; 输出结果： Java and Python:We love you!token34 = 40 预定义宏&emsp;&emsp;ANSI C 定义了许多宏。在编程中你直接可以使用这些宏，但是不能直接修改这些预定义的宏。 123456789101112131415161718#include &lt;stdio.h&gt;int func(int a)&#123; printf("Function :%s\n",__FUNCTION__); //当前所在的函数名称 return 0;&#125;int main()&#123; printf("File :%s\n", __FILE__ ); //当前文件名，一个字符串常量。 printf("Date :%s\n", __DATE__ ); //当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 printf("Time :%s\n", __TIME__ ); //当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。 printf("Line :%d\n", __LINE__ ); //这会包含当前行号，一个十进制常量。 printf("ANSI :%d\n", __STDC__ ); //当编译器以 ANSI 标准编译时，则定义为 1 func(1); return 0;&#125; 输出结果： File :C:\a1-C\Test\main.cDate :Apr 28 2018Time :10:35:28Line :14ANSI :1Function :func]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+GitHub+next搭建博客]]></title>
    <url>%2F2018%2F04%2F22%2Fhexo%2BGitHub%2Bnext%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很久之前就想搭个属于自己的独立的博客，最近终于付之于行动了。这几天在网上了找了很多相关的资料，了解到了用hexo+github的方法搭建一个简便的博客。把这几天找到有用的网站整理一下，方便以后再深入了解。 1、基于windows系统的基本环境配置环境 需要安装的软件：Node.js和Git 注册Github账号，创建代码库，部署本地文件到GitHub 安装Hexo 初始化Hexo,首次体验Hexo 2、更换主题&emsp;&emsp;首次体验的Hexo主题是默认的，网站上有很多好看的主题。我选的主题是:next。在很多的主题中非常喜欢这个，简单大气，又功能俱全。接下来贴出next主题的相关配置链接。 首先是官方文档 官方文档比较全面但不详细，可以对照着看，具体操作还得看其他博主的博客基础配置 基础配置过后就可以来升级版了，让自己的博客具有更多的功能从而更好看升级配置 再补充一个偶然看到标签云的高级配置标签云这个也是有官方文档 在使用next主题前，我是使用Yelee主题的，我感觉next主题更好一点，不过萝卜白菜各有所爱。这里贴出Yelee主题的使用说明 3、注册域名&emsp;&emsp;在腾讯云买了域名，就像在淘宝买东西一样，输入自己想要的域名(例如：abc.cn、abc.com等等)，只要之前没人注册过，然后下单付钱。之后需要实名认证，实名认证的认证需要2到3个工作日。等实名认证通过了，你就可以解析域名了。可以自己购买服务器，将域名解析，也可以不花一分钱的可以直接绑定到GitHub上(富人靠金币，穷人靠科技，hhhhh)。操作步骤： 1、在你的域名管理有一个解析的选项，添加两条记录类型为CNAME的解析，一条主机记录为@，一条主机记录为www，记录值都为你的格式为username.github.io的地址。 2、在你的本地hexo博客文件的source文件夹下创建一个CNAME文件，记住不要有文件后缀名。编辑CNAME文件，里面写你在第一步申请的域名，例如：xxxx.cn，记住不要有www。3、在你本地博客文件里运行hexo g，再运行hexo d。4、在浏览器输入你申请的域名，你会发现该域名已经指向了你在github上的博客了。ps：设置域名解析需要几分钟的时间，完成以上步骤依然无法访问，请过几分钟再尝试访问。 4、补充&emsp;&emsp;在之后的使用中发现浏览器的留白太多，导致博客文章宽度不够，代码的查阅十分不方便。解决方案：next/source/css/_variables/custom.styl文件中添加 $main-desktop = 1200px $content-desktop = 900px 5、最后&emsp;&emsp;现在终于有一个独立域名的博客:computerkid.cn。弄了快两个星期，不过百度和Google并没有收录，现在也不急，目前就当做自己个人的日记一样，直接在浏览器输入网址就行。收录的问题。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Welcome to My Blog！ 1.我搭建博客的目的：&emsp;&emsp;记录平时学习的东西、解决的问题、浏览的有趣的网站等等，做一个总结和整理，方便以后还能找到。一切都是兴趣使然！ 2.强烈推荐阅读： 书写是为了更好的思考 为什么你应该(从现在开始就)写博客 123456//C#include &lt;stdio.h&gt;int main()&#123; printf("Hello World!")&#125; 1234567//C++#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl;&#125; 12345678910//Javapublic class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println("Hello World"); &#125;&#125; 12#Pythonprint("Hello World")]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
