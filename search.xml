<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有关编程的小知识]]></title>
    <url>%2F2018%2F05%2F25%2F%E6%9C%89%E5%85%B3%E7%BC%96%E7%A8%8B%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近学python，一些关于编程的基本概念又重头过了一遍，整理一下。 计算机&emsp;&emsp;计算机是根据指令操作数据的设备。它可以用来看电影，办公，打游戏。但这些只是它的功能，而不是它！&emsp;&emsp;计算机由硬件和软件系统组成。&emsp;&emsp;功能性：对数据的操作，表现为数据计算、输入输出处理和结果存储等。&emsp;&emsp;可编程性：根据一系列指令自动地、可预测地、准确地完成操作者的意图。 摩尔定律 计算机发展史上最重要的预测法则 Intel公司创始人之一戈登.摩尔在1956年提出 单位面积集成电路上可容纳的晶体管数量约每两年翻一番 CPU/GPU、内存、硬盘等都遵循摩尔定律 计算机的发展参照摩尔定律，表现为指数形式 计算机程序&emsp;&emsp;计算机程序(Computer Program)是指一组指示计算机或其他具有消息处理能力装置每一步动作的指令，通常用某种程序设计语言编写，运行于某种目标体系结构上。打个比方，一个程序就像一个用汉语(程序设计语言)写下的红烧肉菜谱(程序)，用于指导懂汉语(编译器)同时也会烹饪手法的人(体系结构)来做这道菜。这个例子简直完美，摘自维基百科计算机程序。 程序设计语言&emsp;&emsp;程序设计语言是一种语言，如同汉语、英语。语言是为了个体与个体之间的交流，此处个体不限于人类。程序设计语言即编程语言是一种用于人与计算机交互(交流)的人造语言。编程语言相比人类的自然语言更简单(是的,简单)、更严谨、更精确。编程语言种类很多，但生命力强劲的却不多，编程语言有超过600多种，绝大部分都不再使用。查看语言排名的官网：TIOBE。这个网站会不断更新不同编程语言的使用的比例和受欢迎的趋势等等。 编程语言的执行方式&emsp;&emsp;计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成机器语言，也就是机器码。 计算机执行源程序的两种方式：编译和解释。 源代码：采用某种编程语言(高级语言)编写的计算机程序，人类可读。 目标代码：目标代码是一串由0,1组成的二进制代码(机器码)，也只有这样的目标代码才能被计算机直接执行，其他编程语言编写的代码都需要转换成二进制代码。人类不可读，专家除外。 编译：将源代码一次性转换成目标代码的过程。一次翻译，之后不再需要源代码，类似翻译一本英文书。 编译型语言：C、C++等等。 解释：将源代码逐条转换为目标代码同时逐条执行的过程。每次出现运行时都需要翻译源代码，类似实时的同声传译。 解释型语言：Pyhton、Java等等。 静态语言和脚本语言&emsp;&emsp;静态、脚本语言和编译型、解释型语言是不同的分类。&emsp;&emsp;静态语言和动态语言的区别]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[星巴克logo的来源]]></title>
    <url>%2F2018%2F05%2F20%2F%E6%98%9F%E5%B7%B4%E5%85%8Blogo%E7%9A%84%E6%9D%A5%E6%BA%90%2F</url>
    <content type="text"><![CDATA[The design of this logo began in Seattle in 1971. 这个标志的设计诞生于1971年的西雅图。 With three university friends who really liked coffee. 出自三位喜欢咖啡的大学朋友。 They also really liked the Herman Melville novel Moby Dick. 他们也很喜欢赫尔曼·梅尔维尔的小说《白鲸》。 So much so, they decided to name their company after Captain Ahab’s ship. 出于喜爱，他们决定以亚哈船长的船命名他们的公司。 But branding exec Terry Heckler decided Pequod coffee didn’t sound quite right. 但负责起名的泰瑞·郝克勒觉得”裴阔德咖啡”听起来很别扭。 So they went with the name of the first-mate: Starbuck. 于是他们以大副的名字”星巴克”来命名。 Heckler then trawled through maritime books and found a 15th century woodcut of a two-tailed siren. 后来，郝克勒查阅海事书籍，发现了个版画，画着15世纪的双尾海妖。 Instead of luring sailors onto the rocks, this mythical mermaid would call people to come and grab a cup of coffee. 这个神秘美人鱼的用处不是诱惑水手，而是吸引人们来喝咖啡。 Initially her chest was bare, but after some complaints Heckler redrew the design with long hair that covered her body. 最初，她的胸部是裸露的，但遭到吐槽，郝克勒重新设计，用长发遮The design of this logo began in Seattle in 1971. 这个标志的设计诞生于1971年的西雅图。 With three university friends who really liked coffee. 出自三位喜欢咖啡的大学朋友。 They also really liked the Herman Melville novel Moby Dick. 他们也很喜欢赫尔曼·梅尔维尔的小说《白鲸》。 So much so, they decided to name their company after Captain Ahab’s ship. 出于喜爱，他们决定以亚哈船长的船命名他们的公司。 But branding exec Terry Heckler decided Pequod coffee didn’t sound quite right. 但负责起名的泰瑞·郝克勒觉得”裴阔德咖啡”听起来很别扭。 So they went with the name of the first-mate: Starbuck. 于是他们以大副的名字”星巴克”来命名。 Heckler then trawled through maritime books and found a 15th century woodcut of a two-tailed siren. 后来，郝克勒查阅海事书籍，发现了个版画，画着15世纪的双尾海妖。 Instead of luring sailors onto the rocks, this mythical mermaid would call people to come and grab a cup of coffee. 这个神秘美人鱼的用处不是诱惑水手，而是吸引人们来喝咖啡。 Initially her chest was bare, but after some complaints Heckler redrew the design with long hair that covered her body. 最初，她的胸部是裸露的，但遭到吐槽，郝克勒重新设计，用长发遮挡她的身体。 The logo also went from brown to green, a symbol of freshness and growth. 标志也是从褐色改成绿色，象征朝气和生长。 In 2011, the Starbucks siren was redesigned with rounder details, a longer shadow was also introduced on the right side of her nose. 2011年，星巴克修改海妖标志，去掉外圈，加长她鼻子右侧的阴影。 A small element of asymmetry which made her feel more human. 左右脸不对称，她会更像人类。 She can be spotted in 76 countries and markets, helping Starbucks to reach a brand value of more than 8.7 billion dollars. 星巴克已经进驻76个国家的市场，借此，品牌价值已经超过87亿美元。 Bold and alluring this is the design that started with a myth and became a coffee legend. 大胆而诱人的设计，来源于神话，如今成为咖啡界传奇。挡她的身体。 The logo also went from brown to green, a symbol of freshness and growth. 标志也是从褐色改成绿色，象征朝气和生长。 In 2011, the Starbucks siren was redesigned with rounder details, a longer shadow was also introduced on the right side of her nose. 2011年，星巴克修改海妖标志，去掉外圈，加长她鼻子右侧的阴影。 A small element of asymmetry which made her feel more human. 左右脸不对称，她会更像人类。 She can be spotted in 76 countries and markets, helping Starbucks to reach a brand value of more than 8.7 billion dollars. 星巴克已经进驻76个国家的市场，借此，品牌价值已经超过87亿美元。 Bold and alluring this is the design that started with a myth and became a coffee legend. 大胆而诱人的设计，来源于神话，如今成为咖啡界传奇。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows+Ubuntu双系统删除Ubuntu]]></title>
    <url>%2F2018%2F05%2F12%2FWindows%2BUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4Ubuntu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近Ubuntu18.04版本发布了！加上之前在已经安装16.04版本瞎捣鼓，正好换个系统。之前是Windows+Ubuntu双系统，用起来有着诸多麻烦。这次就想把ubuntu系统删了，直接安装在虚拟机里。虽然这样不能充分利用电脑的内存资源，但是作为只是玩玩ubuntu的我还是追求方便，要是一不小心在ubuntu里弄坏了什么，虚拟机里可以直接删了再重装，很方便。趁这个机会，整理一下有关BIOS,Mbr,UEFI,Grub的资料。 按下开机键后发生了什么？&emsp;&emsp;第一次自己尝试捣鼓重装系统时，过程可以说是非常坎坷了，一下子就接触了好多新的专业词汇:BIOS,Mbr,UEFI和Grub等等。&emsp;&emsp;在了解BIOS之前，得看一看计算机的启动过程，在按下开机键后，我们的电脑到底做了哪些事。&emsp;&emsp;计算机的启动过程；&emsp;&emsp;BIOS(来自维基百科，翻墙可访问);&emsp;&emsp;一直叱咤风云的BIOS即将被UEFI BIOS淘汰，新主板将普及UEFI BIOS。&emsp;&emsp;UEFI(来自维基百科，翻墙可访问); Windows+Ubuntu双系统删除Ubuntu&emsp;&emsp;在安装双系统时，就要分清是BIOS还是UEFI了，因为需要根据不同情况选择方案去删除ubuntu这个系统。如果去磁盘直接删除安装ubuntu系统的分区，删完后还是Grub引导，开机的时候会发现进入了Grub的界面并不能进入Windows系统。&emsp;&emsp;UEFI启动Windows10+Ubuntu双系统删除Ubuntu方法；&emsp;&emsp;win10 gpt分区+uefi引导 卸载双系统ubuntu；&emsp;&emsp;EasyUEFI这款强大的软件请在官网下载。本着一个基本原则：所有软件都要在官方网站下载，绝不从什么下载之家、未来软件园下载。这些乱七八糟的网站下载的软件最可恶的就是给你绑定一套全家套软件套餐，毕竟它打广告是有报酬的，甚至软件并不完整，用起来出现什么bug，这影响就大了。最糟的情况就是带着木马病毒什么的，那就很爆炸了。所以所以所以下载软件什么的一定要做官网下！&emsp;&emsp;EasyUEFI官网]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Bios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++自增自减运算符]]></title>
    <url>%2F2018%2F05%2F05%2FC%20or%20C%2B%2B%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现在每天晚上抽点时间复习专业课从C/C++语言开始。C/C++的自增和自减运算符(++和— —)是比较容易出错的一种运算符，运算符++使变量自加1，而运算符— —使变量自减1。 前置运算&emsp;&emsp;++,— —在变量前面，则变量先进行加1或减1运算，然后变量再参与其他运算。1234567891011#include &lt;stdio.h&gt;int main()&#123; //前置运算 int a,b,x=5,y=6; a=++x; //x先自增变成6，再赋值给a，所以a为6 b=--y; //y先自减变成5，再赋值给b，所以b为5 printf("x=%d a=%d y=%d b=%d\n",x,a,y,b); return 0;&#125; 输出结果： x=6 a=6 y=5 b=5 后置运算&emsp;&emsp;++,— —在变量后面，则变量先参与其他运算，然后变量再进行加1或减1运算。 1234567891011#include &lt;stdio.h&gt;int main()&#123; //后置运算 int a,b,x=5,y=6; a=x++; //x先赋值给a，所以a为5，x再自增变成6 b=y--; //y先赋值给b，所以b为6，y再自减变成5 printf("x=%d a=%d y=%d b=%d\n",x,a,y,b); return 0;&#125; 输出结果： x=6 a=5 y=5 b=6 运算符++的优先级高于+&emsp;&emsp;对于x+++y的问题，到底是x+(++y)还是(x++)+y？ 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; //x+++y的值 int a,b,x=5,y=6; a=x+++y; //等同于a=(x++)+y; /* ++的优先级高于+ a=x+++y 等价为 int b=x++; 这里b为5 int a=b+y; */ printf("a=%d\n",a); return 0;&#125; 输出结果： a=11 在函数中的引用&emsp;&emsp;自增++或自减— —运算在for循环或者printf()函数中是从右到左引用的。 1234for(int i=0;i&lt;9;i++) //先算i++，再进行i&lt;9的比较&#123; 代码块;&#125; 123456789101112#include &lt;stdio.h&gt;int main()&#123; int i=3; printf("%d,%d",i,i++); //等同于 //int a=i++; a=3,赋值给a后i变成4 //printf("%d",a); //printf("%d",i); return 0;&#125; 输出结果： 4,3 (++i)+(++i)+(++i)的值1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int i=5; int a=(++i)+(++i)+(++i); //加法运算得先求得两个运算对象的值. //第一个++i,此时i=6; //第二个++i,此时i=7; //所以是7+7=14,此时i=7; //14+(++i)=14+8=22 printf("%d",a); return 0;&#125; 输出结果： 22 举一反三 123456789#include &lt;stdio.h&gt;int main()&#123; int i=5; int a=((++i)+(++i))+((++i)+(++i)); printf("%d",a); return 0;&#125; 输出结果： 32 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int i=5; int a=(++i)+((++i)+(++i))+(++i); //自创hhh /* 第一个(++i)时,i=6 然后进入两重括号，两重括号里的第一个(++i),i=7 两重括号里的第二个(++i),i=8 所以前面是8+(8+8) 到两重括号右边最后一个(++i),i=9 所以最终结果24+9=33 */ printf("%d",a); return 0;&#125; 输出结果： 33 总结&emsp;&emsp;平时写代码肯定不会写成这样，简直折磨自己，如果别人看你的代码肯定分分钟钟想锤你。不过面试或者考试可能会出的这么绕。]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的学习]]></title>
    <url>%2F2018%2F05%2F04%2FMarkdown%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Markdown 是一种电子邮件风格的标记语言。既然搭了博客网站，当然要写博客。我先在本地计算机用Markdown写好文章，再通过git部署到GitHub上的，然后在网页才会显示写的文章。Markdown的基本语法十分简单，一般五分钟就能学完日常基本所需的操作。 为什么选择Markdown&emsp;&emsp;既然写东西为什么不用微软的word,一开始我是有这样的疑惑的。搜了几篇文章后终于知道缘由了。&emsp;&emsp;为什么作家应该用 Markdown 保存自己的文稿。 Markdown教程&emsp;&emsp;献给写作者的 Markdown 新手指南;&emsp;&emsp;简单详细的教程;&emsp;&emsp;官方文档。&emsp;&emsp;看完这三篇基本上就差不多了，美滋滋。 高颜值神器Typora&emsp;&emsp;Typora是一款极致简洁的Markdown编辑器，谁用谁知道。Typora的官网。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git大法好]]></title>
    <url>%2F2018%2F04%2F27%2FGit%E5%A4%A7%E6%B3%95%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近搭博客，强势了解学习了一波git。以前只是注册了GitHub的账号，然后在上面拉一拉别人的代码，就没怎么深入学习了解。现在才发现git的强大美妙之处。现在整理一下这几天的所学习的东西，十分有趣。 git是什么？&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统(没有之一)。这么说可能有点官方，简单来讲git是一款软件，就像手机里的APP，手机的APP都具有相应的功能，git的功能是什么呢？它能帮我们做什么事情呢？ 版本控制系统？&emsp;&emsp;要理解git，就要先了解版本控制系统。见维基百科(只有翻墙了才能访问!)的详细解释。版本控制就我理解来讲：就是你新建一份文档或者一份代码，到最终完成它们，这个过程你一定经过不断修改，每次修改都会产生不同的版本，如图：你需要管理这些版本，有时候需要找回之前版本里的某些内容，这就是手工的版本控制了。手工版本控制工作量在开发大型项目时会十分的大，而且容易出错。所以“懒惰的”软件工程师们设计一款软件自动记录每个版本，你可以很轻松的知道你的文档何时创建的，一共经过几次修改，何时何人修改了什么，甚至可以地回退到某个修改的版本，这些功能只需要输入相应的命令就行。当然，这款软件的强大远不止我说的这些，这只是冰山一角！&emsp;&emsp;这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 文件名 用户 日期 1 论文.doc 张三 4/21 10:30 2 论文.doc 李四 4/22 11:30 3 论文.doc 张三 4/22 12:30 4 论文.doc 张三 4/23 10:30 &emsp;&emsp;这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的21世纪。 git的诞生&emsp;&emsp;很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？&emsp;&emsp;事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。&emsp;&emsp;不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。&emsp;&emsp;安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。&emsp;&emsp;Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。&emsp;&emsp;Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&emsp;&emsp;历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 人人都应该会用Git和GitHub&emsp;&emsp;之前在知乎上搜怎么使用GitHub，看到一个文科妹子的良心回复，详细的介绍了GitHub和为什么人人都应该会使用git和GitHub。给出链接：珊姗是个小太阳。 git的操作教程&emsp;&emsp;大致弄明白了git是什么了，以及它有趣的诞生史，就要真刀真枪的实干了，学习它的基本命令行操作了。这里强烈安利廖雪峰老师的教程。这个教程被称为史上最浅显易懂的教程，我承认它易懂，但一点也不浅显。根据这个教程我学到了git基本的命令行操作，终于可以用上git这款强大美妙的工具了，美滋滋。 快速上手教程&emsp;&emsp;如果只是上传代码到GitHub上，或者从GitHub上拉代码(这些几乎已经满足日常需要了)。点击快速上手教程。 细节问题&emsp;&emsp;用了一段时间的git，我发现：从GitHub上把远程仓库拉到本地，用git clone+地址的命令只能把整个项目全部拉下来，而有时我只需要这个项目的一份文件就行。解决方案：下载一个仓库的单个文件。 总结&emsp;&emsp;这篇博客我是4月27号开始写的，今天是5月4号青年节！其实这之间我每天晚上都在写，本来我是想展开成好几个篇来写的，但是今天突然回去看看了之前写的几篇。发现我把博客写成了教程，emmmmm，我写博客又不是来教别人怎么用，之前我把廖雪峰老师的教程几乎展开写了好几篇。突然发现我好傻，而且有抄袭的嫌疑。我写博客不就是记录自己学习某个东西的过程，以方便以后遗忘回来可以找到之前学习的轨迹和查阅的资料吗？差点走偏了，于是今晚就把学习git的过程中查阅的资料全都整理了一下，感觉这样就够了，这才是我写博客的目的。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C的预处理]]></title>
    <url>%2F2018%2F04%2F24%2FC%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;深入学习C的预处理。C/C++语言的程序第一行一般都是 #include “ “ 或者#include &lt; &gt;,以前只知道它是预处理，其中细节没有研究过。 现在从头再看一遍C，跟当初第一次学习C语言的感觉是完全不一样的（此处感慨省略一千字）。现在有能力深入研究一下C的预处理了，以此篇博客整理一下。 预处理&emsp;&emsp;首先在C/C++语言编译的时候，会经历以下几个步骤：预处理，编译，汇编，链接，然后生成可执行文件。整个过程是一连串动作完成的。而预处理阶段呢，也是最先执行的一个步骤。 定义 以“#”号开头的预处理指令如包含#include,宏定义制定#define等，在源程序中这些指令都放在函数之外，而且一般放在源文件里的最前面几行。预处理就是在对源程序的C代码进行编译之前所作的工作，预处理是C语言的一个重要的功能，它由预处理程序(预处理器)单独完成，当对一个源文件进行编译时，系统自动引用预处理程序，对源程序中的预处理进行一些文本性质的操作。简言之，C预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。 类型 1&gt;宏定义2&gt;条件编译3&gt;文件包含4&gt;预处理操作符#和##，预定义宏 任务 1&gt;将头文件中的内容(.h文件)插入到源文件中 2&gt;进行了宏替换的过程，定义和替换由#define指令定义的符号 3&gt;删除掉注释，注释是不会带入到编译阶段 4&gt;条件编译，根据“#if”后面的条件决定需要编译的代码 指令 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器 宏定义&emsp;&emsp;在C语言中允许用一个标识符来表示一个字符串：称为宏。在预处理时，对程序的宏进行替换。其中宏定义是由源程序中的#define来完成 ，而宏的替换，主要是由预处理程序完成。 1#define PI 3.14159 宏定义的规则 ’#‘表示一条预处理的指令，以’#‘开头的均是预处理指令 #define是宏定义的指令，标识符是所定义的宏名 宏名一般都是大写的字母表示，以便和变量名区别 宏定义其实并不是C语言的语句，所以后面是不用去加” ；“ 宏体可以是常数，表达式，格式化字符串等，为表达式的时候应该用括号括起来 宏替换不分配内存空间，也不做正确性的检查 宏的范围是从定义后到所在源文件结束，但是可以通过#undef来进行提前取消 无参数宏定义、有参数宏定义 无参数宏定义 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;/*无参数宏定义*/#define PI 3.14159#define A 123#define B "Hello World!"//#undef B //取消了宏B的定义，那么宏B就不能再程序中使用/*宏的移除语法#undef 宏名功能：删除前面定义的宏*/int main()&#123; int sum=1,R=2; float s; char str[20]; sum+=A; s=PI*R*R; strcpy(str,B); printf("sum=%d\n",sum); printf("半径为R圆的面积:%.2f\n",s); printf("输出字符串str:%s",str); return 0;&#125; 输出结果: sum=124半径为R圆的面积:12.57输出字符串str:Hello World! 带参数宏定义 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;/*带参数宏定义语法结构：#define [宏名](形参列表) (宏体)形式参数不分配内存单元，没有类型定义注：宏名和形式参数列表之间不能有空格出现。*//*MAX为宏名，紧跟其后(x,y)为形参列表，形参没有类型定义，((x) &gt; (y) ? (x) : (y))为宏体，是一个三目运算。*/#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))#define square(x) ((x) * (x))#define square_1(x) (x * x)int main()&#123; int a; a=MAX(3,5); printf("a=%d\n",a); //宏的本质是直接代入替换参数的位置,文本替换 printf("square(5+4) is %d\n", square(5+4)); //(5+4)*(5+4)=81 printf("square_1(5+4) is %d\n", square_1(5+4)); //5+4*5+4=29 return 0;&#125; 输出结果: a=5square(5+4) is 81square_1(5+4) is 29 从带有参数的宏定义，可以看出在很多场合下，宏可以当成函数使用，但是又和真正的函数是有区别的。区别如下图所示： 对比项 带参数宏定义 函数 处理时间 编译时期 程序运行时期 参数类型 无参数类型 有具体的参数类型 处理过程 不分配内存，简单字符的置换 分配内存，先求得实参，再传递给形参 程序长度 会变长 不变 运行速度 不会占用运行时间 调用和返回会占用时间 支持递归 不支持 支持 条件编译 概念 一般情况下，源程序中所有的行都进行编译，但是有时希望对其中一部分内容满足一定条件下才进行编译，也就是对一部分内容指定编译条件，这就是条件编译。 优点 条件编译可以指定代码的一部分是被正常编译还是被完全忽略 ,条件编译有利于提升程序的可移植性，增强程序 的灵活性。 语法 编译语法一： 1234567891011#ifdef 标识符(宏名) //或者#if define(标识符) 程序段1 #else 程序段2 #endif 实例：防止多重包含的问题产生#define HELLO "helloworld"#ifdef HELLO #define HI "welcome"#endif 编译语法二： 12345678910111213#ifndef 标识符（宏名） //或#if !define(标识符) 程序段1 #else 程序段2 #endif实例：#ifndef __HELLO_H__ #define __HELLO_H__ void out();#else //程序段2#endif 编译语法三： 123456789101112131415161718192021#if(常量表达式) 程序段1#elif(常量表达式2) 程序段2 #else 程序段3 #endif实例代码：#define C1 0#define C2 0 #define C3 1#if(C1) #include "c1.h"#elif(C2) #include "c2.h"#elif(C3) #include "c3.h"#else #include "c.h"#endif 文件包含 概念 文件包含是C预处理程序的另一个重要的功能，被包含的文件名字必须使用双引号” “(自定义头文件)，或者&lt; &gt;(标准库文件)括起来。例如：#include&lt;math.h&gt;,#include “myfunction.h”。 功能 一个源文件可以将另外一个源文件的内容包含进来，从而把指定的文件和当前的源文件连成一个源文件。 文件包含的处理过程： 在预处理的时候，用被包含文件的内容取代该文件包含指令，再对包含后的文件作一个源文件编译。 文件多重包含问题 概念：同一个文件被包含多次 结果：多重包含可能会出现重复定义的编译错误 解决方案：使用条件编译来防止多重包含,凡是在头文件前后，用条件编译去编译。 123456//如标准头文件的写法：#ifndef __HEADER_NAME_H__#define __HEADER_NAME_H__#include "headername.h"//其他的代码#endif 建议：在头文件中尽量不要去定义一些全局变量，可以在源文件中去定义，用extern去修饰。extern的用法。 预处理操作符和预定义宏 预处理操作符&emsp;&emsp;C语言中有两个预处理操作符号#。操作符号#通常成为字符串化的操作符号，它把其后的串变成用双引号包围的串。连接操作符号##可以把两个独立的字符串链接成一个字符串。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//一个宏通常写在一个单行上.但是如果宏太长,//一个单行容纳不下，则使用宏延续运算符"\"//当需要把一个宏的参数转换为字符串常量时,则使用字符串常量化运算符"#"#define message_for(a,b) \ printf(#a " and " #b ":We love you!\n")//宏定义内的标记粘贴运算符"##"会合并两个参数.//它允许在宏定义中两个独立的标记被合并为一个标记//这里的token##n=token+n,而n在main()里是34,so token##n=token34=40#define tokenpaster(n) printf("token" #n " = %d\n", token##n)int main()&#123; message_for(Java,Python); int token34 = 40; tokenpaster(34); return 0;&#125; 输出结果： Java and Python:We love you!token34 = 40 预定义宏&emsp;&emsp;ANSI C 定义了许多宏。在编程中你直接可以使用这些宏，但是不能直接修改这些预定义的宏。 123456789101112131415161718#include &lt;stdio.h&gt;int func(int a)&#123; printf("Function :%s\n",__FUNCTION__); //当前所在的函数名称 return 0;&#125;int main()&#123; printf("File :%s\n", __FILE__ ); //当前文件名，一个字符串常量。 printf("Date :%s\n", __DATE__ ); //当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 printf("Time :%s\n", __TIME__ ); //当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。 printf("Line :%d\n", __LINE__ ); //这会包含当前行号，一个十进制常量。 printf("ANSI :%d\n", __STDC__ ); //当编译器以 ANSI 标准编译时，则定义为 1 func(1); return 0;&#125; 输出结果： File :C:\a1-C\Test\main.cDate :Apr 28 2018Time :10:35:28Line :14ANSI :1Function :func]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+GitHub+next搭建博客]]></title>
    <url>%2F2018%2F04%2F22%2Fhexo%2BGitHub%2Bnext%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很久之前就想搭个属于自己的独立的博客，最近终于付之于行动了。这几天在网上了找了很多相关的资料，了解到了用hexo+github的方法搭建一个简便的博客。把这几天找到有用的网站整理一下，方便以后再深入了解。 基于windows系统的基本环境配置环境 需要安装的软件：Node.js和Git 注册Github账号，创建代码库，部署本地文件到GitHub 安装Hexo 初始化Hexo,首次体验Hexo 更换主题&emsp;&emsp;首次体验的Hexo主题是默认的，网站上有很多好看的主题。我选的主题是:next。在很多的主题中非常喜欢这个，简单大气，又功能俱全。接下来贴出next主题的相关配置链接。 首先是官方文档 官方文档比较全面但不详细，可以对照着看，具体操作还得看其他博主的博客基础配置 基础配置过后就可以来升级版了，让自己的博客具有更多的功能从而更好看升级配置 再补充一个偶然看到标签云的高级配置标签云这个也是有官方文档 在使用next主题前，我是使用Yelee主题的，我感觉next主题更好一点，不过萝卜白菜各有所爱。这里贴出Yelee主题的使用说明 注册域名&emsp;&emsp;在腾讯云买了域名，就像在淘宝买东西一样，输入自己想要的域名(例如：abc.cn、abc.com等等)，只要之前没人注册过，然后下单付钱。之后需要实名认证，实名认证的认证需要2到3个工作日。等实名认证通过了，你就可以解析域名了。可以自己购买服务器，将域名解析，也可以不花一分钱的可以直接绑定到GitHub上(富人靠金币，穷人靠科技，hhhhh)。操作步骤： 1、在你的域名管理有一个解析的选项，添加两条记录类型为CNAME的解析，一条主机记录为@，一条主机记录为www，记录值都为你的格式为username.github.io的地址。 2、在你的本地hexo博客文件的source文件夹下创建一个CNAME文件，记住不要有文件后缀名。编辑CNAME文件，里面写你在第一步申请的域名，例如：xxxx.cn，记住不要有www。3、在你本地博客文件里运行hexo g，再运行hexo d。4、在浏览器输入你申请的域名，你会发现该域名已经指向了你在github上的博客了。ps：设置域名解析需要几分钟的时间，完成以上步骤依然无法访问，请过几分钟再尝试访问。 补充&emsp;&emsp;在之后的使用中发现浏览器的留白太多，导致博客文章宽度不够，代码的查阅十分不方便。解决方案：next/source/css/_variables/custom.styl文件中添加 $main-desktop = 1200px $content-desktop = 900px 最后&emsp;&emsp;现在终于有一个独立域名的博客:computerkid.cn。弄了快两个星期，不过百度和Google并没有收录，现在也不急，目前就当做自己个人的日记一样，直接在浏览器输入网址就行。收录的问题。]]></content>
      <categories>
        <category>计算机相关技术应用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Welcome to My Blog！ 我搭建博客的目的：&emsp;&emsp;记录平时学习的东西、解决的问题、浏览的有趣的网站等等，做一个总结和整理，方便以后还能找到。一切都是兴趣使然！ 强烈推荐阅读： 书写是为了更好的思考 为什么你应该(从现在开始就)写博客 123456//C#include &lt;stdio.h&gt;int main()&#123; printf("Hello World!")&#125; 1234567//C++#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello World!"&lt;&lt;endl;&#125; 12345678910//Javapublic class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println("Hello World"); &#125;&#125; 12#Pythonprint("Hello World")]]></content>
      <categories>
        <category>程序设计语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
